/*
 * Copyright 2012 University of Helsinki.
 * 
 * This file is part of BMVis.
 *
 * BMVis is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * BMVis is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public
 * License along with BMVis.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

package biomine.bmvis;

import biomine.bmgraph.BMGraph;
import biomine.bmgraph.BMEdge;
import biomine.bmgraph.BMEntity;
import biomine.bmgraph.BMNode;
import biomine.bmgraph.attributes.AttributeType;
import biomine.bmgraph.attributes.Parser;

import prefuse.Visualization;
import prefuse.data.Edge;
import prefuse.data.Graph;
import prefuse.data.Node;
import prefuse.data.Schema;
import prefuse.data.Table;
import prefuse.visual.VisualItem;

import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;

/**
 * BMGraph to Prefuse graph conversion and intermediate layer.
 * <p>The idea is to simultaneously maintain two data structures of
 * the same graph, one for the BMGraph format and one for Prefuse. It is
 * assumed that the existence of nodes and edges remains constant, and
 * there is no support for the addition or deletion of nodes or edges
 * from either the BMGraph or Prefuse Graph side. However, attributes
 * can be synchronized in both directions, subject only to the
 * limitation that no globally new attributes can be added to the
 * Prefuse Graph (i.e. only attributes such that were set for some node
 * or edge in the original graph, or that are part of the "standard"
 * attributes, may be set later for nodes and edges respectively).
 *
 * <p>Note that no automatic synchronization occurs between the two
 * representations of the same graph. This must be achieved by explicit
 * calls.
 * @author Kimmo Kulovesi
 */

public class PrefuseBMGraph {

    /**
     * Edge key for the from-node (row in nodes table).
     */
    public static final String FROM_KEY = Graph.DEFAULT_SOURCE_KEY;

    /**
     * Edge key for the to-node (row in nodes table).
     */
    public static final String TO_KEY = Graph.DEFAULT_TARGET_KEY;

    /**
     * Edge key for the edgenode boolean (true iff an edgenode).
     */
    public static final String EDGENODE_KEY = "_edgenode";

    /**
     * Edge key for the arrowedge boolean (true iff the arrowedge).
     */
    public static final String ARROW_KEY = "_arrowedge";

    /**
     * Node and edge key for type (node type or linktype as String).
     */
    public static final String TYPE_KEY = "type";

    /**
     * Node key for the DBID (Database:ID as String).
     */
    public static final String DBID_KEY = "database_id";

    /**
     * Node key for the DB (Database as String).
     */
    public static final String DB_KEY = "database";

    /**
     * Node key for the ID (ID in Database as String).
     */
    public static final String ID_KEY = "id_in_db";

    /**
     * Node and edge key for position (in BMGraph, as String).
     */
    public static final String POS_KEY = "pos";

    /**
     * Node and edgenode key for x-position (in Prefuse graph, double).
     */
    public static final String POS_X_KEY = "pos_x";

    /**
     * Node and edgenode key for y-position (in Prefuse graph, double).
     */
    public static final String POS_Y_KEY = "pos_y";

    /**
     * Node and edge(node) key for stored status of pinning (boolean).
     * Note that in the Visualization the pin status is the return value
     * of "isFixed()" for nodes (real or edgenodes), and this
     * information is synced into the graphs only when positions are.
     */
    public static final String PINNED_KEY = "pinned";

    /**
     * Prefuse Node key for their "special" status (boolean). In the BMGraph
     * this is not an attribute of the nodes but rather the membership
     * in the graph-specific set of special nodes.
     */
    public static final String SPECIAL_KEY = "special";

    /**
     * Prefuse edge key for the link to the virtual edgenode (node id).
     */
    public static final String EDGE_TO_EDGENODE_LINK_KEY = "_vnode";

    /**
     * Prefuse node and edgenode key for the corresponding BMEntity.
     */
    public static final String BMENTITY_LINK_KEY = "_bmentity";

    /**
     * Computed label key (String[], generated by the Visualization).
     */
    public static final String COMPUTED_LABEL_KEY = "_label";

    /**
     * Computed rendering parameters key (generated by the Visualization).
     */
    public static final String COMPUTED_PARAMS_KEY = "_render";

    /**
     * Computed fill color key (Integer, generated by the Visualization).
     */
    public static final String COMPUTED_FILL_COLOR_KEY = "_fill";

    /**
     * Fill color R/G/B override key (String, read from graph).
     */
    public static final String RGB_FILL_COLOR_KEY = "fill";

    /**
     * Computed stroke color key (Integer, generated by the Visualization).
     */
    public static final String COMPUTED_STROKE_COLOR_KEY = "_linecolor";

    /**
     * Stroke color R/G/B override key (String, read from graph).
     */
    public static final String RGB_STROKE_COLOR_KEY = "linecolor";

    /**
     * Node and edge custom label key (String, read from graph).
     */
    public static final String LABEL_KEY = "label";

    /**
     * Groupnode key (in Prefuse graph, boolean).
     */
    public static final String GROUPNODE_KEY = "_groupnode";

    /*
     * Groupedge key (in Prefuse graph, boolean).
    public static final String GROUPEDGE_KEY = "_groupedge";
     */

    /**
     * Node members count key (in Prefuse graph, int).
     */
    public static final String NODESIZE_KEY = "_nodesize";

    /**
     * Node alias (queried as) key (String, read from graph).
     */
    public static final String ALIAS_KEY = "alias";

    /**
     * Edge relevance key (double, read from graph).
     */
    public static final String RELEVANCE_KEY = "relevance";

    /**
     * Edge reliability key (double, read from graph).
     */
    public static final String RELIABILITY_KEY = "reliability";

    /**
     * Edge rarity key (double, read from graph).
     */
    public static final String RARITY_KEY = "rarity";

    /**
     * Edge goodness key (double, read from graph).
     */
    public static final String GOODNESS_KEY = "goodness";

    /**
     * Node or edge URL key (String, read from graph).
     */
    public static final String URL_KEY = "url";

    /**
     * Node or edge TTNR key (double, read from graph or generated).
     */
    public static final String TTNR_KEY = "ttnr";

    /**
     * Node or edge KTNR key (double, read from graph or generated).
     */
    public static final String KTNR_KEY = "ktnr";
    
    /**
     * Node or edge shortest paths key (boolean).
     */
    public static final String SHORTEST_KEY = "shortest";

    /**
     * Node or edge minimal paths key (boolean).
     */
    public static final String MINIMAL_KEY = "minimal";

    /**
     * Node or edge source database name key (String, read from graph).
     */
    public static final String SOURCE_DB_NAME_KEY = "source_db_name";

    /**
     * Node or edge source database version key (String, read from graph).
     */
    public static final String SOURCE_DB_VERSION_KEY = "source_db_version";

    /**
     * Node organism key (String, read from graph).
     */
    public static final String ORGANISM_KEY = "organism";

    /**
     * Node query set key (String).
     */
    public static final String QUERYSET_KEY = "queryset";

    /**
     * Reversed edge key (in Prefuse graph, boolean).
     */
    public static final String REVERSED_EDGE_KEY = "_reversed";


    /**
     * The set of "standard" attributes for nodes, mapped to their types.
     * This is pre-populated with the set of standard attributes used by the
     * Biomine project.
     *
     * <p>The intended usage of this map is to force the type for known
     * attributes (instead of inferring it from the graph) and to force
     * the presence of the attribute in the graph so classes using the
     * graph don't have to check its availability every time.
     *
     * <p>Note that changes to this map only take effect in the
     * constructor, so the attributes must be set before the actual
     * instance of the graph is created.
     */
    public static final HashMap<String, Class> STANDARD_NODE_ATTRIBUTES =
                                                   new HashMap<String, Class>();

    /**
     * The set of "standard" attributes for edges (edgenodes), mapped to
     * their types. This is pre-populated with the set of standard attributes
     * used by the Biomine project. It is ensured that the graph will always
     * support the setting and retrieval of these attributes.
     *
     * <p>The intended usage of this map is to force the type for known
     * attributes (instead of inferring it from the graph) and to force
     * the presence of the attribute in the graph so classes using the
     * graph don't have to check its availability every time.
     *
     * <p>Note that changes to this map only take effect in the
     * constructor, so the attributes must be set before the actual
     * instance of the graph is created.
     */
    private static final HashMap<String, Class> STANDARD_EDGE_ATTRIBUTES =
                                                   new HashMap<String, Class>();

    /**
     * The set of non-viewable attributes that shouldn't be directly
     * shown to the user in a visualization. This is pre-populated with
     * most of the attributes used internally by this class, as well
     * as some non-viewable legacy attributes used by the Biomine project.
     * For example, the attribute "color" is non-viewable by default,
     * as the user probably doesn't want to read "red", but instead
     * a mechanism should be implemented to paint the node in red.
     *
     * <p>Note that changes to this set only take effect in the
     * constructor, so the attributes must be set before the actual
     * instance of the graph is created.
     */
    public static final HashSet<String> NON_VIEWABLE_ATTRIBUTES =
                                                    new HashSet<String>();

    // The sets of reserved attributes (not set from BMGraph attributes)
    private static final HashMap<String, Class> RESERVED_NODE_ATTRIBUTES =
                                                   new HashMap<String, Class>();
    private static final HashMap<String, Class> RESERVED_EDGE_ATTRIBUTES =
                                                   new HashMap<String, Class>();

    // Attributes that are human-viewable though reserved
    private static final HashMap<String, Class> VIEWABLE_NODE_ATTRIBUTES =
                                                   new HashMap<String, Class>();
    private static final HashMap<String, Class> VIEWABLE_EDGE_ATTRIBUTES =
                                                   new HashMap<String, Class>();

    // Edge attributes that are only stored in the edgenode
    private static final HashSet<String> NODE_ONLY_EDGE_ATTRIBUTES =
                                                    new HashSet<String>();
    // Edge attributes that are only stored in the edge (not the edgenode)
    private static final HashSet<String> EDGE_ONLY_EDGE_ATTRIBUTES =
                                                    new HashSet<String>();

    static {
        //STANDARD_NODE_ATTRIBUTES.put(SOURCE_DB_NAME_KEY, String.class);
        //STANDARD_NODE_ATTRIBUTES.put(SOURCE_DB_VERSION_KEY, String.class);
        STANDARD_NODE_ATTRIBUTES.put(GOODNESS_KEY, double.class);
        STANDARD_NODE_ATTRIBUTES.put(TTNR_KEY, double.class);
        STANDARD_NODE_ATTRIBUTES.put(KTNR_KEY, double.class);
        STANDARD_NODE_ATTRIBUTES.put(URL_KEY, String.class);
        STANDARD_NODE_ATTRIBUTES.put(LABEL_KEY, String.class);
        STANDARD_NODE_ATTRIBUTES.put(RGB_FILL_COLOR_KEY, String.class);
        STANDARD_NODE_ATTRIBUTES.put(RGB_STROKE_COLOR_KEY, String.class);
        //STANDARD_NODE_ATTRIBUTES.put(SHORTEST_KEY, boolean.class);
        //STANDARD_NODE_ATTRIBUTES.put(MINIMAL_KEY, boolean.class);

        STANDARD_EDGE_ATTRIBUTES.putAll(STANDARD_NODE_ATTRIBUTES);
        STANDARD_EDGE_ATTRIBUTES.put(RELEVANCE_KEY, double.class);
        STANDARD_EDGE_ATTRIBUTES.put(RELIABILITY_KEY, double.class);
        STANDARD_EDGE_ATTRIBUTES.put(RARITY_KEY, double.class);
        STANDARD_EDGE_ATTRIBUTES.put(GOODNESS_KEY, double.class);
        STANDARD_EDGE_ATTRIBUTES.put(RGB_STROKE_COLOR_KEY, String.class);

        STANDARD_NODE_ATTRIBUTES.put(QUERYSET_KEY, String.class);
        STANDARD_NODE_ATTRIBUTES.put(ORGANISM_KEY, String.class);
        STANDARD_NODE_ATTRIBUTES.put(ALIAS_KEY, String.class);

        VIEWABLE_EDGE_ATTRIBUTES.put(TYPE_KEY, String.class);

        VIEWABLE_NODE_ATTRIBUTES.put(TYPE_KEY, String.class);
        VIEWABLE_NODE_ATTRIBUTES.put(DBID_KEY, String.class);

        RESERVED_NODE_ATTRIBUTES.put(GROUPNODE_KEY, boolean.class);
        RESERVED_NODE_ATTRIBUTES.put(NODESIZE_KEY, int.class);
        RESERVED_NODE_ATTRIBUTES.put(COMPUTED_LABEL_KEY, String[].class);
        RESERVED_NODE_ATTRIBUTES.put(COMPUTED_PARAMS_KEY, Object.class);
        RESERVED_NODE_ATTRIBUTES.put(BMENTITY_LINK_KEY, BMEntity.class);
        NODE_ONLY_EDGE_ATTRIBUTES.addAll(RESERVED_NODE_ATTRIBUTES.keySet());

        RESERVED_NODE_ATTRIBUTES.put(COMPUTED_FILL_COLOR_KEY, Integer.class);
        RESERVED_NODE_ATTRIBUTES.put(COMPUTED_STROKE_COLOR_KEY, Integer.class);
        RESERVED_NODE_ATTRIBUTES.putAll(VIEWABLE_NODE_ATTRIBUTES);

        RESERVED_NODE_ATTRIBUTES.put(DB_KEY, String.class);
        RESERVED_NODE_ATTRIBUTES.put(ID_KEY, String.class);
        RESERVED_NODE_ATTRIBUTES.put(SPECIAL_KEY, boolean.class);

        RESERVED_NODE_ATTRIBUTES.put(POS_KEY, String.class);
        RESERVED_NODE_ATTRIBUTES.put(POS_X_KEY, double.class);
        RESERVED_NODE_ATTRIBUTES.put(POS_Y_KEY, double.class);
        RESERVED_NODE_ATTRIBUTES.put(PINNED_KEY, boolean.class);
        RESERVED_NODE_ATTRIBUTES.put(EDGENODE_KEY, boolean.class);
        RESERVED_NODE_ATTRIBUTES.put(REVERSED_EDGE_KEY, boolean.class);

        RESERVED_EDGE_ATTRIBUTES.put(FROM_KEY, int.class);
        RESERVED_EDGE_ATTRIBUTES.put(TO_KEY, int.class);
        RESERVED_EDGE_ATTRIBUTES.put(ARROW_KEY, boolean.class);
        //RESERVED_EDGE_ATTRIBUTES.put(GROUPEDGE_KEY, boolean.class);
        RESERVED_EDGE_ATTRIBUTES.put(EDGE_TO_EDGENODE_LINK_KEY, int.class);
        RESERVED_EDGE_ATTRIBUTES.put(COMPUTED_STROKE_COLOR_KEY, Integer.class);
        RESERVED_EDGE_ATTRIBUTES.put(COMPUTED_FILL_COLOR_KEY, Integer.class);

        EDGE_ONLY_EDGE_ATTRIBUTES.addAll(RESERVED_EDGE_ATTRIBUTES.keySet());

        RESERVED_EDGE_ATTRIBUTES.putAll(RESERVED_NODE_ATTRIBUTES);
        RESERVED_EDGE_ATTRIBUTES.putAll(VIEWABLE_EDGE_ATTRIBUTES);

        NON_VIEWABLE_ATTRIBUTES.add("color");
        NON_VIEWABLE_ATTRIBUTES.add("fill");
        NON_VIEWABLE_ATTRIBUTES.add("style");
        NON_VIEWABLE_ATTRIBUTES.add("tooltip");
        NON_VIEWABLE_ATTRIBUTES.add("bgcolor");
        NON_VIEWABLE_ATTRIBUTES.add("fontcolor");
        NON_VIEWABLE_ATTRIBUTES.add("len");
        NON_VIEWABLE_ATTRIBUTES.add("arrowhead");
        NON_VIEWABLE_ATTRIBUTES.add("shape");
        NON_VIEWABLE_ATTRIBUTES.add("queryname");
        NON_VIEWABLE_ATTRIBUTES.add(URL_KEY);
    }

    private BMGraph bmgraph;
    private Graph prefuseGraph;
    private HashMap<BMNode, Integer> nodeRows;
    private HashMap<BMEdge, Integer> edgeNodeRows;
    private HashMap<String, Class> nodeAttributes;
    private HashMap<String, Class> edgeAttributes;
    private TreeMap<String, Class> viewableNodeAttributes;
    private TreeMap<String, Class> viewableEdgeAttributes;

    /**
     * Get the BMGraph representation of this graph.
     * Note: Edits to this graph are not automatically carried over to Prefuse.
     * @return The BMGraph.
     */
    public BMGraph getBMGraph () {
        return bmgraph;
    }

    /**
     * Get the Prefuse representation of this graph.
     * Note: Edits to this graph are not automatically carried over to BMGraph.
     * @return the Prefuse Graph.
     */
    public Graph getPrefuseGraph () {
        return prefuseGraph;
    }

    /**
     * Check if a given attribute is a valid node attribute for this graph.
     * The set of available node attributes can not be changed after
     * creation of the graph, hence it may be worthwhile to check.
     * @param attribute The attribute to check.
     * @return True iff the attribute is a valid node attribute in this graph.
     */
    public boolean isValidNodeAttribute (String attribute) {
        assert attribute != null : "Null attribute";
        return nodeAttributes.containsKey(attribute);
    }

    /**
     * Check if a given attribute is a valid edge attribute for this
     * graph. Note that it may also be set for virtual nodes
     * representing edges. The set of available attributes can not be
     * changed after creation of the graph, hence it may be worthwhile
     * to check.
     * @param attribute The attribute to check.
     * @return True iff the attribute is a valid edge attribute in this graph.
     */
    public boolean isValidEdgeAttribute (String attribute) {
        assert attribute != null : "Null attribute";
        return edgeAttributes.containsKey(attribute);
    }

    /**
     * Get the set of valid node attributes for this graph. These are
     * the only attributes in the "real" nodes (as represented by
     * BMNodes) that may be set for this graph.
     * @return The set of valid node attributes (unmodifiable).
     */
    public Set<String> getValidNodeAttributes () {
        return Collections.<String>unmodifiableSet(nodeAttributes.keySet());
    }

    /**
     * Get the set of valid edge attributes for this graph. These are
     * the only attributes in the "real" edges (as represented by
     * BMEdges) that may be set for this graph.
     * @return The set of valid edge attributes (unmodifiable).
     */
    public Set<String> getValidEdgeAttributes () {
        return Collections.<String>unmodifiableSet(edgeAttributes.keySet());
    }

    /**
     * Get the map of viewable node attributes for this graph. These
     * attribute-type pairs represent the set of attributes that are set
     * in the Prefuse Nodes representing real nodes (not edgenodes) and
     * are suitable for direct viewing in the visualization.
     * @return The mapping of viewable node attributes to types (unmodifiable).
     */
    public Map<String, Class> getViewableNodeAttributes () {
        return Collections.<String, Class>unmodifiableMap(viewableNodeAttributes);
    }

    /**
     * Get the map of viewable edge attributes for this graph. These
     * attribute-type pairs represent the set of attributes that are set
     * in the Prefuse Edges, as well as Nodes representing edges, and
     * are suitable for direct viewing in the visualization.
     * @return The mapping of viewable edge attributes to types (unmodifiable).
     */
    public Map<String, Class> getViewableEdgeAttributes () {
        return Collections.<String, Class>unmodifiableMap(viewableEdgeAttributes);
    }

    /**
     * Get the BMNode for a given Prefuse node id.
     * @param node Prefuse id (row) for the node (must not be an edgenode).
     * @return Corresponding BMNode, null if not found (e.g. id is an edgenode).
     */
    public BMNode getBMNode (int node) {
        Node prefuseNode = prefuseGraph.getNode(node);
        if (prefuseNode == null || prefuseNode.getBoolean(EDGENODE_KEY))
            return null;
        return (BMNode)prefuseNode.get(BMENTITY_LINK_KEY);
    }

    /**
     * Get the Prefuse Node id for a given BMNode.
     * @param node A BMNode.
     * @return Corresponding row in the Prefuse node table, -1 if not found.
     */
    public int getPrefuseNodeId (BMNode node) {
        assert node != null : "Null node";
        Integer row = nodeRows.get(node);
        return (row == null ? -1 : row);
    }

    /**
     * Get the Prefuse Node for a given BMNode.
     * @param node A BMNode.
     * @return Corresponding Prefuse Node, null if not found.
     */
    public Node getPrefuseNode (BMNode node) {
        assert node != null : "Null node";
        Integer row = nodeRows.get(node);
        if (row == null)
            return null;
        return prefuseGraph.getNode(row);
    }

    /**
     * Get the BMEdge for a given Prefuse node id, which must be an edgenode.
     * @param edgeNode Prefuse id (row) for the edgenode.
     * @return Corresponding BMEdge, null if not found (e.g. not an edgenode).
     */
    public BMEdge getBMEdge (int edgeNode) {
        Node prefuseNode = prefuseGraph.getNode(edgeNode);
        if (prefuseNode == null || !prefuseNode.getBoolean(EDGENODE_KEY))
            return null;
        return (BMEdge)prefuseNode.get(BMENTITY_LINK_KEY);
    }

    /**
     * Get the BMEntity for a given Prefuse node or edgenode id.
     * @param row Row in the Prefuse node table.
     * @return Corresponding BMEntity, null if not found.
     */
    public BMEntity getBMEntity (int row) {
        Node prefuseNode = prefuseGraph.getNode(row);
        if (prefuseNode == null)
            return null;
        return (BMEntity)prefuseNode.get(BMENTITY_LINK_KEY);
    }

    /**
     * Get the BMNode for a given Prefuse Node.
     * @param node Prefuse Node (must not be an edgenode).
     * @return Corresponding BMNode, null if not found (e.g. id is an edgenode).
     */
    public BMNode getBMNode (Node node) {
        if (node == null || node.getBoolean(EDGENODE_KEY))
            return null;
        return (BMNode)node.get(BMENTITY_LINK_KEY);
    }

    /**
     * Get the BMEdge for a given Prefuse Node, which must be an edgenode.
     * @param edgeNode Prefuse Node representing an edge.
     * @return Corresponding BMEdge, null if not found (e.g. not an edgenode).
     */
    public BMEdge getBMEdge (Node edgeNode) {
        assert edgeNode != null : "Null edgeNode";
        if (edgeNode == null || !edgeNode.getBoolean(EDGENODE_KEY))
            return null;
        return (BMEdge)edgeNode.get(BMENTITY_LINK_KEY);
    }

    /**
     * Get the BMEntity for a given Prefuse node or edgenode.
     * @param node Prefuse Node.
     * @return Corresponding BMEntity, null if not found.
     */
    public BMEntity getBMEntity (Node node) {
        assert node != null : "Null node";
        return (BMEntity)node.get(BMENTITY_LINK_KEY);
    }

    /**
     * Get the Prefuse Node id for the virtual node representing
     * a given BMEdge.
     * @param edge A BMEdge.
     * @return Corresponding row in the Prefuse node table, -1 if not found.
     */
    public int getPrefuseNodeId (BMEdge edge) {
        assert edge != null : "Null edge";
        Integer row = edgeNodeRows.get(edge);
        return (row == null ? -1 : row);
    }

    /**
     * Get the Prefuse Node representing the label of a BMEdge.
     * @param edge A BMEdge.
     * @return Corresponding virtual Prefuse Node, null if not found.
     */
    public Node getPrefuseNode (BMEdge edge) {
        assert edge != null : "Null edge";
        Integer row = edgeNodeRows.get(edge);
        if (row == null)
            return null;
        return prefuseGraph.getNode(row);
    }

    /**
     * Get the Prefuse node id for the virtual node representing an Edge.
     * Warning: May throw an exception if used on edges other than those
     * prepared by this class.
     * @param prefuseEdge A Prefuse edge.
     * @return The corresponding virtual node's id (row).
     */
    public int getVirtualNodeId (Edge prefuseEdge) {
        assert prefuseEdge != null : "Null prefuseEdge";
        return prefuseEdge.getInt(EDGE_TO_EDGENODE_LINK_KEY);
    }

    /**
     * Get the Prefuse Node for the virtual node representing an Edge.
     * Warning: May throw an exception if used on edges other than those
     * prepared by this class.
     * @param prefuseEdge A Prefuse edge.
     * @return The corresponding virtual node, or null if not found.
     */
    public Node getVirtualNode (Edge prefuseEdge) {
        assert prefuseEdge != null : "Null prefuseEdge";
        return prefuseGraph.getNode(prefuseEdge.getInt(EDGE_TO_EDGENODE_LINK_KEY));
    }

    /**
     * Get the BMEdge for a given Prefuse Edge.
     * @param prefuseEdge A Prefuse edge.
     * @return The corresponding BMEdge, or null if not found.
     */
    public BMEdge getBMEdge (Edge prefuseEdge) {
        assert prefuseEdge != null : "Null prefuseEdge";
        return getBMEdge(prefuseEdge.getInt(EDGE_TO_EDGENODE_LINK_KEY));
    }

    private void syncAttributes (BMEntity entity, Node pn,
                                 Map<String, Class> reservedAttributes) {
        HashMap<String, String> attributes = entity.getAttributes();
        if (attributes == null)
            return;

        for (String key : attributes.keySet()) {
            if (!reservedAttributes.containsKey(key)) {
                if (pn.canGetBoolean(key))
                    entity.put(key, pn.getBoolean(key) ? "1" : "0");
                else if (pn.canGetString(key))
                    entity.put(key, pn.getString(key));
            }
        }
    }

    /**
     * Sync attributes from an edgenode to the actual Prefuse Edges.
     * @param bmedge BMGraph edge (for the list of attributes).
     * @param pn Prefuse node for the edge.
     */
    private void syncEdgenodeToEdges (BMEdge bmedge, Node pn) {
        for (String key : bmedge.getAttributes().keySet()) {
            Class type = pn.getColumnType(key);
            if (type == null)
                continue;
            Iterator<Edge> edges = pn.edges();
            while (edges.hasNext()) {
                Edge pe = edges.next();
                if (pe.canSet(key, type))
                    pe.set(key, pn.get(key));
            }
        }
    }

    /**
     * Copy node and edge attributes from the Prefuse Graph to the BMGraph.
     * Only those attributes that are already present in the BMGraph
     * nodes are copied, excluding reserved attributes (such as POS_KEY).
     * Additionally, attributes from Prefuse edgenodes are copied to the
     * corresponding real Prefuse Edges.
     *
     * Positions can be obtained from a visualization by calling
     * "updatePositionsFromVisualization()".
     */
    public void syncAttributesToBMGraph () {
        for (BMNode bmnode : bmgraph.getNodes()) {
            Node pn = getPrefuseNode(bmnode);
            if (pn != null)
                syncAttributes(bmnode, pn, RESERVED_NODE_ATTRIBUTES);
        }
        for (BMEdge bmedge : bmgraph.getEdges()) {
            Node pn = getPrefuseNode(bmedge);
            if (pn == null)
                continue;
            syncAttributes(bmedge, pn, RESERVED_NODE_ATTRIBUTES);
            syncEdgenodeToEdges(bmedge, pn);
        }
    }

    /**
     * Copy node and edge attributes from the BMGraph to the Prefuse Graph.
     * Most reserved attributes are not copied from the BMGraph, because
     * e.g. copying "pos" would require recomputing "pos_x" and "pos_y"
     * and possibly updating those to a Visualization. As an exception
     * to this, the "special" attribute for nodes is set to match the
     * special nodes in the BMGraph.
     *
     * Note that for changes in the BMGraph to things beyond just
     * attributes, it is recommended to first synchronize attributes
     * TO the BMGraph (syncAttributesToBMGraph() and possibly also
     * updatePositionsFromVisualization()), then make the changes
     * and create an entirely new PrefuseBMGraph from the changed graph.
     *
     * DEBUG: This is entirely untested. But this is how it should work.
     */
    public void syncAttributesToPrefuseGraph () {
        int row;
        Table nodes = prefuseGraph.getNodeTable();

        for (BMNode bmnode : bmgraph.getNodes()) {
            row = getPrefuseNodeId(bmnode);
            if (row >= 0)
                setEntityAttributes(row, bmnode, nodes, RESERVED_NODE_ATTRIBUTES);
            nodes.setBoolean(row, SPECIAL_KEY, bmgraph.hasSpecialNode(bmnode));
        }

        for (BMEdge bmedge : bmgraph.getEdges()) {
            row = getPrefuseNodeId(bmedge);
            if (row < 0)
                continue;
            setEntityAttributes(row, bmedge, nodes, RESERVED_EDGE_ATTRIBUTES);
            syncEdgenodeToEdges(bmedge, prefuseGraph.getNode(row));
        }
    }

    /**
     * Update all node positions (pos-attribute) from a given visualization.
     * The corresponding "canvas" special comment is also updated in
     * (or added to) the BMGraph comments.
     * @param vis The Visualization from which to obtain positions.
     */
    public void updatePositionsFromVisualization (Visualization vis) {

        double x, y;
        double min_x = 0.0, min_y = 0.0;
        double max_x = 50.0, max_y = 50.0;
        String pos;
        Node pn;
        VisualItem vi;
        String fmt;

        for (BMNode bmnode : bmgraph.getNodes()) {
            pn = getPrefuseNode(bmnode);
            if (pn == null)
                continue;
            vi = vis.getVisualItem(BMVis.GRAPH_NODES, pn);
            if (vi == null)
                continue;
            x = vi.getX();
            vi.setDouble(POS_X_KEY, x);
            if (x > max_x) max_x = x; else if (x < min_x) min_x = x;
            y = vi.getY();
            vi.setDouble(POS_Y_KEY, y);
            if (y > max_y) max_y = y; else if (y < min_y) min_y = y;
            if (vi.isFixed()) {
                fmt = "%.4f,%.4f";
                bmnode.remove(PINNED_KEY);
            } else {
                fmt = "%.1f,%.1f";
                bmnode.put(PINNED_KEY, "0");
            }
            pn.setBoolean(PINNED_KEY, vi.isFixed());
            pos = String.format((java.util.Locale)null, fmt, x, y);
            bmnode.put(POS_KEY, pos);
            pn.setString(POS_KEY, pos);
        }

        for (BMEdge bmedge : bmgraph.getEdges()) {
            pn = getPrefuseNode(bmedge);
            if (pn == null)
                continue;
            vi = vis.getVisualItem(BMVis.GRAPH_NODES, pn);
            if (vi == null)
                continue;
            x = vi.getX();
            vi.setDouble(POS_X_KEY, x);
            if (x > max_x) max_x = x; else if (x < min_x) min_x = x;
            y = vi.getY();
            vi.setDouble(POS_Y_KEY, y);
            if (y > max_y) max_y = y; else if (y < min_y) min_y = y;
            if (vi.isFixed()) {
                fmt = "%.4f,%.4f";
                bmedge.put(PINNED_KEY, "1");
            } else {
                fmt = "%.1f,%.1f";
                bmedge.remove(PINNED_KEY);
            }
            pn.setBoolean(PINNED_KEY, vi.isFixed());
            pos = String.format((java.util.Locale)null, fmt, x, y);
            bmedge.put(POS_KEY, pos);
            pn.setString(POS_KEY, pos);
        }

        // Update the canvas comment, leave 3% border
        double border_x = (max_x - min_x) * 0.03;
        double border_y = (max_y - min_y) * 0.03;

        min_x -= border_x; max_x += border_x;
        min_y -= border_y; max_y += border_y;

        String canvas = String.format((java.util.Locale)null,
                        "%.1f,%.1f,%.1f,%.1f",
                        min_x, min_y, max_x, max_y);
        bmgraph.setSpecialComment("canvas", canvas);
    }

    private boolean setNodePosition (Table nodes, int row, String pos) {
        if (pos == null)
            return false;

        int comma = pos.indexOf(',');
        if (comma > 0) {
            try {
                nodes.set(row, POS_X_KEY,
                    Double.parseDouble(pos.substring(0, comma)));
                nodes.set(row, POS_Y_KEY,
                    Double.parseDouble(pos.substring(comma + 1)));
                return true;
            } catch (Exception e) {
                // Ignore exceptions from parsing numbers
            }
        }
        return false;
    }

    /**
     * Create a new PrefuseBMGraph by converting a BMGraph to Prefuse.
     * @param graph The BMGraph to convert.
     */
    public PrefuseBMGraph (BMGraph graph) {
        assert graph != null : "Null graph";

        bmgraph = graph;
        
        Schema nodeSchema = new Schema();
        Schema edgeSchema = new Schema();

        // Create schema for node attributes

        HashMap<String, AttributeType> inferredTypes;
        inferredTypes = AttributeType.inferFromValues(graph.getNodes());
        nodeAttributes = new HashMap<String, Class>(inferredTypes.size(), 0.9f);
        System.err.println("Inferred node attribute types: "+inferredTypes);
        for (String key : inferredTypes.keySet())
            nodeAttributes.put(key, inferredTypes.get(key).getJavaClass());
        inferredTypes = null;
        nodeAttributes.putAll(RESERVED_NODE_ATTRIBUTES);
        nodeAttributes.putAll(STANDARD_NODE_ATTRIBUTES);
        for (String key : nodeAttributes.keySet())
            nodeSchema.addColumn(key, nodeAttributes.get(key));

        // Create schema for edge attributes (also affects node schema, as we
        // use virtual nodes to represent edge labels)

        inferredTypes = AttributeType.inferFromValues(graph.getEdges());
        edgeAttributes = new HashMap<String, Class>(inferredTypes.size(), 0.9f);
        System.err.println("Inferred edge attribute types: "+inferredTypes);
        for (String key : inferredTypes.keySet())
            edgeAttributes.put(key, inferredTypes.get(key).getJavaClass());
        inferredTypes = null;
        edgeAttributes.putAll(RESERVED_EDGE_ATTRIBUTES);
        edgeAttributes.putAll(STANDARD_EDGE_ATTRIBUTES);
        for (String key : edgeAttributes.keySet()) {
            Class type = edgeAttributes.get(key);
            if (!NODE_ONLY_EDGE_ATTRIBUTES.contains(key))
                edgeSchema.addColumn(key, type);
            if (!EDGE_ONLY_EDGE_ATTRIBUTES.contains(key) &&
                !nodeAttributes.containsKey(key)) {
                nodeSchema.addColumn(key, type);
            }
        }

        // Remove reserved attributes from the maps

        for (String key : RESERVED_NODE_ATTRIBUTES.keySet()) {
            nodeAttributes.remove(key);
            edgeAttributes.remove(key);
        }
        for (String key : RESERVED_EDGE_ATTRIBUTES.keySet()) {
            edgeAttributes.remove(key);
        }
        viewableNodeAttributes = new TreeMap<String, Class>();
        viewableEdgeAttributes = new TreeMap<String, Class>();
        viewableNodeAttributes.putAll(nodeAttributes);
        viewableNodeAttributes.putAll(VIEWABLE_NODE_ATTRIBUTES);
        viewableEdgeAttributes.putAll(edgeAttributes);
        viewableEdgeAttributes.putAll(VIEWABLE_EDGE_ATTRIBUTES);
        for (String key : NON_VIEWABLE_ATTRIBUTES) {
            viewableNodeAttributes.remove(key);
            viewableEdgeAttributes.remove(key);
        }

        // Create tables for nodes and edges

        int row;
        nodeSchema.lockSchema();
        edgeSchema.lockSchema();
        Table nodes = nodeSchema.instantiate();
        Table edges = edgeSchema.instantiate();
        nodeRows = new HashMap<BMNode, Integer>(bmgraph.numNodes());
        edgeNodeRows = new HashMap<BMEdge, Integer>(bmgraph.numEdges());

        // Populate node table

        for (BMNode node : bmgraph.getNodes()) {
            row = nodes.addRow();
            nodeRows.put(node, row);
            setEntityAttributes(row, node, nodes, RESERVED_NODE_ATTRIBUTES);
            nodes.setInt(row, NODESIZE_KEY, bmgraph.getNodeSize(node));
            nodes.setBoolean(row, EDGENODE_KEY, false);
            nodes.setBoolean(row, GROUPNODE_KEY, bmgraph.hasGroupNode(node));
            nodes.setBoolean(row, SPECIAL_KEY, bmgraph.hasSpecialNode(node));
            nodes.setString(row, TYPE_KEY, node.getType());
            nodes.setString(row, DBID_KEY, node.getId());
            {
                String splitId[] = node.splitId();
                if (splitId != null) {
                    nodes.setString(row, DB_KEY, splitId[0]);
                    nodes.setString(row, ID_KEY, splitId[1]);
                }
            }
            nodes.setBoolean(row, PINNED_KEY,
                             setNodePosition(nodes, row, node.get(POS_KEY)));
            if ("0".equals(node.get(PINNED_KEY)))
                nodes.setBoolean(row, PINNED_KEY, false);
            nodes.set(row, BMENTITY_LINK_KEY, node);
        }

        // Populate edge table and add virtual nodes to the node table

        int vnode;
        BMNode from, to;
        String linktype; 
        // String reversed;
        for (BMEdge edge : bmgraph.getEdges()) {
            if (edge.isReversed()) {
                from = edge.getTo();
                to = edge.getFrom();
                linktype = bmgraph.getReadableReverseType(edge);
            } else {
                from = edge.getFrom();
                to = edge.getTo();
                linktype = bmgraph.getReadableType(edge);
            }
            linktype = linktype.replace('_', ' ');

            // Create virtual node
            vnode = nodes.addRow();
            edgeNodeRows.put(edge, vnode);
            nodes.setString(vnode, LABEL_KEY, linktype);
            setEntityAttributes(vnode, edge, nodes, RESERVED_EDGE_ATTRIBUTES);
            nodes.setString(vnode, TYPE_KEY, linktype);
            nodes.setBoolean(vnode, EDGENODE_KEY, true);
            nodes.setBoolean(vnode, SPECIAL_KEY, false);
            nodes.setBoolean(vnode, REVERSED_EDGE_KEY, edge.isReversed());
            nodes.set(vnode, BMENTITY_LINK_KEY, edge);

            if (!setNodePosition(nodes, vnode, edge.get(POS_KEY))) {
                String from_pos = from.get(POS_KEY);
                String to_pos = to.get(POS_KEY);
                if (from_pos != null && to_pos != null) {
                    // Compute position for virtual node if the edge has none
                    int from_comma = from_pos.indexOf(',');
                    int to_comma = to_pos.indexOf(',');
                    if (from_comma > 0 && to_comma > 0) {
                        try {
                            double x = Double.parseDouble(to_pos.substring(
                                                            0,to_comma));
                            double y = Double.parseDouble(to_pos.substring(
                                                            to_comma+1));
                            x += Double.parseDouble(from_pos.substring(
                                                            0, from_comma));
                            y += Double.parseDouble(from_pos.substring(
                                                            from_comma + 1));
                            nodes.setDouble(vnode, POS_X_KEY, x / 2.0);
                            nodes.setDouble(vnode, POS_Y_KEY, y / 2.0);
                        } catch (Exception e) {
                            // Ignore exceptions from parsing numbers
                        }
                    }
                }
            }
            if ("1".equals(edge.get(PINNED_KEY)))
                nodes.setBoolean(vnode, PINNED_KEY, true);

            // Split each edge into two edges that connect to the virtual node
            row = edges.addRow();
            edges.setInt(row, FROM_KEY, vnode);
            edges.setInt(row, TO_KEY, nodeRows.get(to));
            setEntityAttributes(row, edge, edges, RESERVED_EDGE_ATTRIBUTES);
            edges.setInt(row, EDGE_TO_EDGENODE_LINK_KEY, vnode);
            if (!bmgraph.isSymmetricType(edge.getLinktype()))
                edges.setBoolean(row, ARROW_KEY, true);
            edges.setString(row, TYPE_KEY, edge.getLinktype());
            edges.setBoolean(row, REVERSED_EDGE_KEY, edge.isReversed());
            /*
            edges.setBoolean(row, GROUPEDGE_KEY,
                    (bmgraph.hasGroupNode(from) || bmgraph.hasGroupNode(to)));
                    */

            row = edges.addRow();
            edges.setInt(row, FROM_KEY, nodeRows.get(from));
            edges.setInt(row, TO_KEY, vnode);
            setEntityAttributes(row, edge, edges, RESERVED_EDGE_ATTRIBUTES);
            edges.setInt(row, EDGE_TO_EDGENODE_LINK_KEY, vnode);
            edges.setBoolean(row, ARROW_KEY, false);
            edges.setString(row, TYPE_KEY, edge.getLinktype());
            edges.setBoolean(row, REVERSED_EDGE_KEY, edge.isReversed());
            /*
            edges.setBoolean(row, GROUPEDGE_KEY,
                    (bmgraph.hasGroupNode(from) || bmgraph.hasGroupNode(to)));
                    */
        }

        // Create Prefuse graph from the tables

        prefuseGraph = new Graph(nodes, edges, true);
    }

    /**
     * Set a given BMEntity's attributes to a given row in a table.
     * Reserved attributes are not added.
     * @param row Row in the table.
     * @param entity BMEntity whose attributes to add.
     * @param table The table to which they will be added.
     * @param reservedAttributes The map of reserved attributes.
     */
    protected static void setEntityAttributes (int row, BMEntity entity,
                        Table table, Map<String, Class> reservedAttributes) {
        HashMap<String, String> attributes = entity.getAttributes();
        if (attributes == null)
            return;

        for (String key : attributes.keySet()) {
            if (reservedAttributes.containsKey(key))
                continue;
            Class type = table.getColumnType(key);
            if (type != null) {
                Parser p = AttributeType.getParserFor(type);
                if (p != null) {
                    String s = attributes.get(key);
                    table.set(row, key, p.parse(s));
                }
            }
        }
    }

}
